import bbs
import aes
import key_gen
import send


# init: function to generate the private and public key before encryption or decryption
def init():
    try:
        with open("config.txt", "r") as conf:       # ^
            # print("Opening configuration file")   # | trying to open the file containing saved values for p and g.
            for i in conf.readlines():              # |
                i = i.strip()                       # v
                if (i[0] == "p"):                   # ^
                    if (len(i[2:]) != 0):           # |
                        p = int(i[2:].strip())      # |
                    else:                           # |
                        p = 0                       # | assigning p and g according to the values defined in the config file. If there are not values in the file, the variables are assigned to 0
                elif (i[0] == "g"):                 # |
                    if (len(i[2:]) != 0):           # |
                        g = int(i[2:].strip())      # |
                    else:                           # |
                        g = 0                       # v
    except:                                             # ^
        print("\nFile unavailable or unreadable.\n")    # | if the file is not found or if the format is not respected, the file is considered unreadable and the variables are assigned to 0
        p = 0                                           # |
        g = 0                                           # v
    if (g == 0 or p == 0):                                          # ^
        print("Configuration unavailable.")                         # |
        if (p == 0):                                                # |
            p = input("Please chose a value for parameter p: ")     # | if any variable (p or g) is equal to 0, it must be assigned through lanual input
            p = int(p)                                              # |
        if (g == 0):                                                # |
            g = input("Please chose a value for parameter g: ")     # |
            g = int(g)                                              # v
    # print("\nPlease wait, now verifying if parameters are correct...")
    correct = key_gen.verif_p(p, g)  # verifying that p and g do respect the conditions

    while (
            correct == False):  # if the couple does not respect the conditions, the whole parameter allocation restarts until the couple is correct
        try:
            with open("config.txt", "r+") as conf:
                # print("Opening configuration file")
                for i in conf.readlines():
                    i = i.strip()
                    if (i[0] == "p"):
                        if (len(i[2:]) != 0):
                            p = int(i[2:].strip())
                        else:
                            p = 0
                    elif (i[0] == "g"):
                        if (len(i[2:]) != 0):
                            g = int(i[2:].strip())
                        else:
                            g = 0
        except:
            print("\nFile unavailable or unreadable.\n")
            p = 0
            g = 0
            if (g == 0 or p == 0):
                print("Configuration unavailable.")
                if (p == 0):
                    p = input("Please chose a value for parameter p: ")
                    p = int(p)
                if (g == 0):
                    g = input("Please chose a value for parameter g: ")
                    g = int(g)
        # print("\nPlease wait, now verifying if parameters are correct...")
        correct = key_gen.verif_p(p, g)

    # print("entered parameters: \np = "+str(p)+"\tg = "+str(g)+"\n\ncyclic group available to chose key couples (1 is automatically avoided because forbidden in BBS PRNG algorithm): "+str(key_gen.cycle(p, g)))

    # print("Public and private key couple generation...")
    (pub, prv) = key_gen.gen_keys(p, g)  # generating public and private key
    # print("Public key generated: "+str(pub))
    # print("prv: "+str(prv))
    return pub, prv, p


# main:  function using the different defined functions to realise the encryption
#        or decryption process. The function also supports the interactions with
#        the user
def main(port, text, mode, prv, p):

    opub = 0
    try:
        opub = send.send(port, "getkey")        # getting the public key from the distant node
        opub = int(opub)
    except:
        print("wrong public key")

    shared_k = key_gen.compute_shared(opub, prv, p)     # computing the shared key from the public key received and the private key generated
    # print("\nShared key generated by the algorithm: "+str(shared_k))
    
    rng_k = bbs.main(shared_k)               # computing the random key from the shared key and the generator g
    # print("Key generated by the BBS PRNG algorithm: "+str(rng_k))

    if mode:
        print('\nData to transmit:\n'+str(text)[2:-1])
        res = aes.encrypt(rng_k, text)         # encryption of the plaintext using aes if mode is True
        print('\nEncrypted data:\n'+str(res))
    else:
        print('\nEncrypted data:\n'+str(text)[2:-1])
        res = aes.decrypt(rng_k, text)          # decryption of the plaintext using aes if mode is True
        print('\nPlaintext:\n'+str(res))

    return res
